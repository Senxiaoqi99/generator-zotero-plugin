declare const Zotero: any

declare const Components: any
// declare const Services: any
// Components.utils.import('resource://gre/modules/Services.jsm')

const consoleService = Components.classes['@mozilla.org/consoleservice;1'].getService(Ci.nsIConsoleService)
import { format } from './content/debug.ts'
function debug(...msg) {
  consoleService.logStringMessage(format(msg))
}

Components.utils.import('resource://gre/modules/AsyncShutdown.jsm')
declare const AsyncShutdown: any

function runasync(context, f) {
  f().catch(err => debug(`${context}: ${err.message}\n${err.stack}`))
}

enum Reason {
  APP_STARTUP     = 1, // The application is starting up.
  APP_SHUTDOWN    = 2, // The application is shutting down.
  ADDON_ENABLE    = 3, // The add-on is being enabled.
  ADDON_DISABLE   = 4, // The add-on is being disabled. (Also sent during uninstallation)
  ADDON_INSTALL   = 5, // The add-on is being installed.
  ADDON_UNINSTALL = 6, // The add-on is being uninstalled.
  ADDON_UPGRADE   = 7, // The add-on is being upgraded.
  ADDON_DOWNGRADE = 8, // The add-on is being downgraded.
}

type BootstrapData = {
  id:           string  // The ID of the add-on being bootstrapped.
  version:      string  // The version of the add-on being bootstrapped.
  installPath:  any     // nsIFile; The installation location of the add-on being bootstrapped. This may be a directory or an XPI file depending on whether the add-on is installed unpacked or not.
  resourceURI:  any     // nsIURI; A URI pointing at the root of the add-ons files, this may be a jar: or file: URI depending on whether the add-on is installed unpacked or not.
  oldVersion:   string  // The previously installed version, if the reason is ADDON_UPGRADE or ADDON_DOWNGRADE, and the method is install or startup.
  newVersion:   string  // The version to be installed, if the reason is ADDON_UPGRADE or ADDON_DOWNGRADE, and the method is shutdown or uninstall.
}

const patch_marker = 'Unpatched<%= code.namespace %>'
// eslint-disable-next-line @typescript-eslint/no-unused-vars
function patch(object, method, patcher) {
  if (object[method][patch_marker]) return
  object[method][patch_marker] = object[method]
  object[method] = patcher(object[method])
}

async waitForWindow() {
  return new Promise( resolve => {
    // Check if window is already loaded
    const windows = Services.wm.getEnumerator('navigator:browser');
    while (windows.hasMoreElements()) {
      return resolve(windows.getNext())
    }

    // If not, add a listener for when the window does load
    const windowListener = {
      onOpenWindow: xulWindow => {
        // Wait for the window to finish loading
        const domWindow = xulWindow.QueryInterface(Components.interfaces.nsIInterfaceRequestor).getInterface(Components.interfaces.nsIDOMWindow)

        domWindow.addEventListener('load', () => {
          domWindow.removeEventListener('load', listener, false)
          if (domWindow.document.documentElement.getAttribute('windowtype') === 'navigator:browser') {
            resolve(domWindow)
          }
        }, false)
      },

      onCloseWindow: _xulWindow => {},

      onWindowTitleChange: (_xulWindow, _newTitle) => {},
    }

    // Add listener to load scripts in windows opened in the future
    Services.wm.addListener(windowListener)
  })
}

function install(_data: BootstrapData, _reason: Reason) {
}

function uninstall(_data: BootstrapData, _reason: Reason) {
}

function startup(_data: BootstrapData, _reason: Reason) {
  runasync('<%= plugin.name %> startup', async () => {
    const window = await waitForWindow() as {Zotero: any}
    Services.scriptloader.loadSubScript('chrome://<%= plugin.name %>/content/<%= plugin.name %>.js', window);
  })

  AsyncShutdown.profileBeforeChange.addBlocker('<%= plugin.name %> shutdown', async () => {
    // async shutdown here
  })
}

function shutdown(_data: BootstrapData, _reason: Reason) {
}
